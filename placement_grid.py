#!/usr/bin/env python3

"""
A simple script to create simple gcode for my simple plotter.

Armin H. 2-7-2020
"""
import os
import argparse

def save_gcode_to_file(gc_str, fn):
    with open(fn, 'w') as f:
        f.write(gc_str)
    verbose_print('Saved to file {}'.format(fn))


def parse_args():
    PARSER = argparse.ArgumentParser(description='Make a grid in gcode')
    PARSER.add_argument('width', help='Width of bed (mm)', type=int, nargs=1)
    PARSER.add_argument('height', help='Height of bed (mm)', type=int,nargs=1)    
    PARSER.add_argument('gridspacing', help='Gridspacing (mm).', type=int,nargs=1)
    PARSER.add_argument('-s0', '--speed_g0', help='Speed in mm/min for G0 command (fast placement)',
                        default=4000)
    PARSER.add_argument('-s1', '--speed_g1', help='Speed in mm/min for G1 command (pen movement)',
                        default=1500)
    PARSER.add_argument('-v', '--verbose', help='Print out detailed info.', action="store_true")
    PARSER.add_argument('-o', '--gcode_output', 
                        help='Save gcode to file if file name specified.', type=str, default='')
    PARSER.add_argument('--pen_up', 
                        help='GCode for Pen Up movement.', type=str, default="M3 S120\nG4 P0.5; Pen up\n")
    PARSER.add_argument('--pen_down', 
                        help='GCode for Pen Down movement.', type=str, default="M3 S10\nG4 P0.5; Pen down\n")
    return PARSER.parse_args()
    
def verbose_print(str, v=False):
    # only verbose_print if verbosity is set > 0
    if v:
        print(str)
    else:
        pass
    
def main(config):
    # Draw box around full plotting area
    origin = (0, 0)
    width=config.width[0]
    height=config.height[0]
    gridspacing = config.gridspacing[0]
    v = config.verbose
    gcode_output = config.gcode_output
    # M3 spindle command changes pulse duration of PWM output,
    # driving the RC servo that lifts the pen
    # S10 has pen in down position, S120 in up position
    pen_down = config.pen_down
    pen_up = config.pen_up
    g1_speed = config.speed_g1 # mm/min speed for G1 command
    g0_speed = config.speed_g0 # mm/min speed for G0 command
    if (width % gridspacing) or (height % gridspacing):
        raise ValueError('Width and height need to be divisible by gridspacing.')
    
    verbose_print('Generating GCode for grid\n\n',v)
    gcode_string = """; GCODE Generated by Python script "placement_grid.py"
; Grid for plotter bed
G21; mm-mode
G54; Work Coordinates
G21; mm-mode
G90; Absolute Positioning
; Plotter Mode Active
M3 S120; pen up
G0 Z0
G0 F{s} X{x} Y{y}; go to {x}/{y}
""".format(s=g0_speed, x=origin[0], y=origin[1])
    
    # Draw horizontal lines first:
    c=0 #counter
    for y in range(0,height+gridspacing, gridspacing):
        if c%2 == 0:
            verbose_print("Line from 0/{} to {}/{}".format(y,width,y), v)
            gcode_string += pen_down
            gcode_string += "G1 F{s} X{x} Y{y}; go to {x}/{y}\n".format(s=g1_speed, x=width, y=y)
            gcode_string += pen_up
            if y+gridspacing <= width:
                verbose_print("Goto fast to {}/{}".format(width, y+gridspacing), v)
                gcode_string += "G0 F{s} X{x} Y{y}; go to {x}/{y}\n".format(s=g0_speed, x=width, y=y+gridspacing)
        else:
            verbose_print("Line from {}/{} to 0/{} ".format(width,y,y), v)
            gcode_string += pen_down
            gcode_string += "G1 F{s} X{x} Y{y}; go to {x}/{y}\n".format(s=g1_speed, x=0, y=y)
            gcode_string += pen_up  
            if y+gridspacing <= width:
                verbose_print("Goto fast to 0/{}".format(y+gridspacing), v)
                gcode_string += "G0 F{s} X{x} Y{y}; go to {x}/{y}\n".format(s=g0_speed, x=0, y=y+gridspacing)
        c+=1
    verbose_print("\nDone with horizontal lines\n", v)
    
    # Go back to origin:
    verbose_print("Go fast to 0/0\n", v)
    gcode_string += "G0 F{s} X{x} Y{y}; go to {x}/{y}\n".format(s=g0_speed, x=0, y=0)
    
    # Draw vertical lines:
    c=0
    for x in range(0,width+gridspacing, gridspacing):
        if c%2 == 0:
            verbose_print("Line from {}/0 to {}/{}".format(x,x,height), v)
            gcode_string += pen_down
            gcode_string += "G1 F{s} X{x} Y{y}; go to {x}/{y}\n".format(s=g1_speed, x=x, y=height)
            gcode_string += pen_up
            if x+gridspacing <= width:
                verbose_print("Goto fast to {}/{}".format(x+gridspacing, width), v)        
                gcode_string += "G0 F{s} X{x} Y{y}; go to {x}/{y}\n".format(s=g0_speed, x=x+gridspacing, y=width)
        else:
            verbose_print("Line from {}/{} to {}/0".format(x,height,x), v)
            gcode_string += pen_down
            gcode_string += "G1 F{s} X{x} Y{y}; go to {x}/{y}\n".format(s=g1_speed, x=x, y=0)
            gcode_string += pen_up 
            if x+gridspacing <= width:
                verbose_print("Goto fast to {}/0".format(x+gridspacing), v)
                gcode_string += "G0 F{s} X{x} Y{y}; go to {x}/{y}\n".format(s=g0_speed, x=x+gridspacing, y=0)
        c+=1
    # Go back home
    gcode_string += "G0 F{s} X{x} Y{y}; go to {x}/{y}".format(s=g0_speed, x=0, y=0)

    verbose_print('\n\nGCODE below:\n', v)
    verbose_print(gcode_string, v)
    if gcode_output:
        save_gcode_to_file(gcode_string, gcode_output )
        print('\nGCODE saved to file: {}'.format(gcode_output))

if __name__ == "__main__":
    config = parse_args()
    main(config)
    
    
    
